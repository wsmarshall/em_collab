from pysat.solvers import *
from itertools import *
from sys import argv

#global variable, if N is assigned to "t" later, and a function is called, it will be called with "t"
N = None
he_cut = None 
ge_cut = None 
s_cut = None 
hl_cut = None 
gl_cut = None


#currently, we wish to encode array, splitter, and two types each of edge and linked list variables
#we first encode subscripts

def sub_encode(pos1, pos2):
    return pos1*N + pos2

def sub_decode(val):
    return (val // N, val % N)

def sub_enc3(p1,p2,p3):
    #needs to be this order since second position is implicitly less than n
    return sub_encode(sub_encode(p1,p2),p3)

def sub_dec3(val):
    tup_init = sub_decode(val)
    tup_sec = sub_decode(tup_init[0])
    return (tup_sec[0], tup_sec[1], tup_init[1])

#we will now shift according to var type: array first, then G's linked list, then H's linked list, followed by 
#splitter, G's edge, H's edge. First 3 are N^3, last 3 are N^2
#for some reason can't use N**3, I get "int object not callable" or incorrect results. 
#also can't use dictionary, think this has to do with dictionaries being immutable


def array_enc(p1,p2,p3):
    return sub_enc3(p1,p2,p3) +1

def glink_enc(p1,p2,p3):
    return sub_enc3(p1,p2,p3) + gl_cut

def hlink_enc(p1,p2,p3):
    return sub_enc3(p1,p2,p3) + hl_cut

def split_enc(p1,p2):
    return sub_encode(p1,p2) + s_cut

def gedge_enc(p1,p2):
    return sub_encode(p1,p2) + ge_cut

def hedge_enc(p1,p2):
    return sub_encode(p1,p2) + he_cut

# (pysat data format) : pysat returns (if formula is sat) a list of integers, the negative ones are false, then positive are true
# alternatively, since (pysat data format) is as above, we can binsort, and then just decode using decode_3 or decode


# current thoughts- switch/ case match is available on python 3.11, but idk if compatible w/ PYSAT
# so we essentially need an elif
#assumption: num >=0 ( we only care about true variables)
def individual_decode(num):

    if num >= he_cut: 
        tup = sub_decode(num -he_cut)
        return ("H", tup[0], tup[1])
    elif num >= ge_cut:
        tup = sub_decode(num - (ge_cut))
        return ("G", tup[0], tup[1])
    elif num >= s_cut:
        tup = sub_decode(num-(s_cut))
        return ("s", tup[0], tup[1])
    elif num >= hl_cut:
        tup = sub_dec3(num-(hl_cut))
        return ("hl", tup[0], tup[1], tup[2])
    elif num >= gl_cut:
      tup = sub_dec3(num-(gl_cut))
      return ("gl", tup[0], tup[1], tup[2])
    else: 
        tup = sub_dec3(num-1)
        return ("a", tup[0], tup[1], tup[2])


#code for decoding result of binsort array goes here if we decide to implement


# PySAT solves formulas in conjunctive normal form, i.e., an 
# "and-of-ors". Each time you add a clause, you list out the variables,
# negating them if they are negated in the formula. E.g., if we wanted
# to include the clause (x_1 V x_2 V ~x_3), we would write
# "phi.add_clause([1, 2, -3])

def at_most_one(phi, indices):
    for i,j in combinations(indices, 2):
        phi.add_clause([-i, -j])

def at_least_one(phi, indices):          
    phi.add_clause(list(indices))

def exactly_one(phi, indices):
    at_least_one(phi, indices)
    at_most_one(phi, indices)

    #a_(u,i,v) true iff u's rotation is st positiion i is occupied by vertex v
    #l_(u,v,w) true iff u's rotations is st w comes after v

#compute degree of all vertices
def degree_dic(edges):
    degree = {}
    for x in range(len(edges)):
        val = 0
        for i in range(len(edges[x])):
            if edges[x][i] == True:
                val +=1
        degree.update({x: val})
    return degree


def find_rotation(edges, constraint = ''):
    # the solver starts out with an empty formula, and we add our desired clauses
    deg = degree_dic(edges)
    #print(deg)
    phi = Glucose4()

    #exactly one constraints (section 6.3 in tim's writeup)
    # "for any fixed u, only one v can be in position i"
    for u in range(N):
        for i in range(deg[u]):
            exactly_one(phi, [array_enc(u,i,v) for v in range(N)])
    
    for u in range(N):
        for v in range(N):
            if edges[u][v]:
                exactly_one(phi, [array_enc(u,i,v) for i in range(deg[u])])

    for u in range(N): 
        exactly_one(phi, [split_enc(u,i) for i in range(N)])

    #at most one constraints (6.3)    

    for u in range(N):
        for w in range(N):
                at_most_one(phi, [glink_enc(u,v,w) for v in range(N)])
                at_most_one(phi, [glink_enc(u,w,v)for v in range(N)])  
                at_most_one(phi, [hlink_enc(u,v,w) for v in range(N)])
                at_most_one(phi, [hlink_enc(u,w,v)for v in range(N)])             

 
    #Constraints section 6.4, in order: 
    #for array variables, no vertices can occupy a position greater than degree of u
    c1, c2, c3, c4 = [],[],[],[]
    for u in range(N):
        for i in range(deg[u], N):
            for v in range(N):
                # tup = (0,u,i,v)
                # print(tup)
                c1.append(-array_enc(u,i,v))
                phi.add_clause([-array_enc(u,i,v)])

    # print("c1:")
    # print(c1)
    #Array Var: for all vertices, no position can be occupied by a non neighbor
    for u in range(N):
        for v in range(N):
            if not edges[u][v]:
                for i in range(N):
                    c2.append(-array_enc(u,i,v))
                    phi.add_clause([-array_enc(u,i,v)])
    
    #print("c2")
    #print(c2)
    #Linked List var: for all vertices nonneighbors cannot follow or be followed by anything
    for u in range(N):
        for v in range(N):
            if not edges[u][v]:
                for w in range(N):
                    #c3.append(-glink_enc(u,v,w))
                    phi.add_clause([-glink_enc(u,v,w)])
                    phi.add_clause([-hlink_enc(u,v,w)])
                    #c4.append(-glink_enc(u,w,v))
                    phi.add_clause([-glink_enc(u,w,v)])
                    phi.add_clause([-hlink_enc(u,w,v)])

    # print("c3")
    # print(c3)
    # print("c4")
    # print(c4)

    #splitter constraint- can't split above degree of u
    for u in range(N): 
        for i in range(deg[u], N): 
            phi.add_clause([-split_enc(u,i)])

    #6.4 edge constraint- if not an edge, doesn't appear as an H-edge or G-edge
    for u in range(N):
        for v in range(N):
            if not edges[u][v]:
                phi.add_clause([-gedge_enc(u,v)])
                phi.add_clause([-hedge_enc(u,v)])

    #6.5 constraints, in order (convert to CNF using wolfram alpha)
    for u in range(N):
        for v in range(N):
            if edges[u][v]:
                phi.add_clause([-gedge_enc(u,v), gedge_enc(v,u)])
                phi.add_clause([gedge_enc(u,v), -gedge_enc(v,u)])
                phi.add_clause([-hedge_enc(u,v), hedge_enc(v,u)])
                phi.add_clause([hedge_enc(u,v), -hedge_enc(v,u)])
                phi.add_clause([-gedge_enc(u,v), -hedge_enc(u,v)])
                phi.add_clause([gedge_enc(u,v), hedge_enc(u,v)])
                
    #6.6 constraints, in order
    for u in range(N):
        for v in range(N):
            phi.add_clause(-array_enc(u,0,v), gedge_enc(u,v))
            phi.add_clause(-array_enc(u,deg[u]-1,v), hedge_enc(u,v))

    #away from the splitter
    for u in range(N):
        for i in range(N): 
            for v in range(N):
                for w in range(N):
                    phi.add_clause([-array_enc(u,i,v), -array_enc(u,i+1,w), split_enc(u,i),glink_enc(u,v,w), hlink_enc(u,v,w)])

    for u in range(N):
        for i in range(N): 
            for v in range(N): 
                for w in range(N):
                    phi.add_clause([-array_enc(u,i,v), -array_enc(u,0,w), -split_enc(u,i), glink_enc(u,v,w)])

    for u in range(N):
            for i in range(N): 
                for v in range(N): 
                    for w in range(N):
                        phi.add_clause([-array_enc(u,deg[u]-1, v), -array_enc(u,i+1,w), -split_enc(u,i),hlink_enc(u,v,w)])
    

    #6.7 delta* constraints: 
    for u in range(N):
         for v in range(N):
             for w in range(N): 
                phi.add_clause([-glink_enc(u,v,w), glink_enc(v,w,u)])
                phi.add_clause([-glink_enc(u,v,w), glink_enc(w,u,v)])
                phi.add_clause([-hlink_enc(u,v,w), hlink_enc(v,w,u)])
                phi.add_clause([-hlink_enc(u,v,w), hlink_enc(w,u,v)])

    #6.8 constraints
    for u in range(N): 
        for v in range(N): 
            for w in range(N):
                phi.add_clause([-glink_enc(u,v,w), -glink_enc(u,w,v)])
                phi.add_atmost([-hlink_enc(u,v,w), -hlink_enc(u,w,v)])

    for u in range(N):
        phi.add_clause([-split_enc(u,0)])
        phi.add_clause([-split_enc(u,1)])
        phi.add_clause([-split_enc(u,deg[u]-1)])
        phi.add_clause([-split_enc(u,deg[u]-2)])
        phi.add_clause([-split_enc(u,deg[u]-3)])

    #6.9 possible redundant constraints
    for v in range(N):
        at_least_one(phi,[gedge_enc(u,v) for u in range(N)])
        at_least_one(phi,[hedge_enc(u,v) for u in range(N)])

    for u in range(N):
        for i in range(N):
            for j in range(i, N):
                for v in range(N):
                    phi.add_clause(-array_enc(u,i,v), -split_enc(u,j), gedge_enc(u,v))

    for u in range(N):
        for j in range(N):
            for i in range(j+1, N):
                for v in range(N):
                    phi.add_clause([-array_enc(u,i,v), -split_enc(u,u), hedge_enc(u,v)])

                
    #code for enforcing additional user added constraint if wanted goes here


    if phi.solve():
        #k>0 picks out the true variables
        model = sorted([individual_decode(k) for k in phi.get_model() if k > 0])
        print(model)
        return model
